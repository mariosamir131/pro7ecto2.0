<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Principal</title>
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <!-- JavaScript Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous">
    </script>
    <link rel="stylesheet" href="style.css" ;>
</head>

<body>
    <nav class="nav navbar navbar-expand-lg bg-dark">
        <a class="nav-link active" aria-current="page" href="index.php">Menu</a>
        <a class="nav-link" href="principal.php">Principal</a>
        <a class="nav-link" href="formulario.php">Formulario</a>
        <a class="nav-link" href="tabla.php">Tabla</a>
    </nav>

    <div class="container mt-5">
        <h2 class="titleF">Informacion General</h2>
        <hr>
        <h4 class="subtitle">Maderas y Zoologico</h4>
        <p class="contenido">
            La madera es un material natural que lleva siglos acompañando al ser humano. Somos conscientes de que los
            seres humanos somos transformadores del medio y durante toda nuestra historia hemos estado utilizando la
            madera que nos han dado los árboles para mejorar nuestras condiciones de vida. Todavía, en el siglo XXI, no
            sabemos bien qué es la madera y, sobre todo, cómo se obtiene. Para nosotros, que trabajamos con relojes de
            madera, gafas de sol de madera y regalos originales de madera, saber qué es la madera, cómo se obtiene y
            resolver algunas cuestiones relacionadas con la misma es esencial. Empezaremos con preguntas básicas y
            después veremos un abecedario con diferentes tipos de madera según el árbol del que proceden. Entre todas
            estas maderas, encontrarás algunas con las que están fabricados nuestros relojes especiales. Si quieres ver
            todo el contenido, puedes desplegarlo aquí y hacer clic en la parte que más te interese.
        </p>
        <br>
        <p class="contenido">
            Zoológico es un adjetivo que se emplea para nombrar a lo vinculado a la zoología, que es la ciencia que se
            dedica a estudiar a los animales. El término, de todos modos, suele usarse como sustantivo para nombrar al
            parque zoológico (también conocido como jardín zoológico).

            ZoológicoEn este sentido, un zoológico es un espacio donde se crían y cuidan animales para exhibirlos al
            público. Estos recintos combinan el ocio con la enseñanza, ya que suelen apuntar a entretener y, a la vez,
            educar a los visitantes. También, cuando están en manos privadas, buscan una ganancia económica por su
            funcionamiento.

            Existen más un millar de zoológicos en todo el mundo. El primer establecimiento moderno de este tipo fue el
            zoológico de Viena, inaugurado a mediados del siglo XVIII. Hasta entonces, existían colecciones privadas de
            animales, por lo general creadas por monarcas.
        </p>
        <center>
            <div class="container mt-5">
                <img src="imagenes/maderaanimales" width="500px" heigth="500px">
            </div>
        </center>
        <br>
        <h4 class="subtitle">Pastelería</h4>
        <p class="contenido">
            El término pastelería se refiere al establecimiento donde se producen o se comercializan distintos tipos de
            alimentos dulces, como pasteles, tortas, tartas, facturas y otros.

            Por ejemplo: “Por favor, ve hasta la pastelería y compra una tarta de fresas antes de que llegue la abuela
            Mirta”, “¡Entrar a esta pastelería es una tentación! Todo lo que ofrece me parece delicioso”, “Lo primero
            que aprendí cuando empecé a trabajar en la pastelería de mi padre fue a decorar tortas”..
        </p>
        <center>
            <div class="container mt-5">
                <img src="imagenes/pasteleria.webp" width="500px" heigth="500px">
            </div>
        </center>
        <br>
        <h4 class="subtitle">Gastronomía</h4>
        <p class="contenido">
            La gastronomía es la disciplina, comprendida como un arte, que estudia las relaciones del ser humano con su
            modo de alimentación y con el entorno cultural en el que la cocina se da.

            La gastronomía brinda una aproximación a la cultura empleando la comida como eje central. Se ocupa tanto de
            técnicas de cocción, datos nutricionales y ciencias alimenticias, como del manejo profesional de los sabores
            y aromas en la confección de un platillo culinario.

            La gastronomía no es simplemente el gusto por la comida o por cocinar. De hecho, esta disciplina se ocupa de
            múltiples apreciaciones de lo cultural en torno a la cocina y la alimentación, como la elección de los
            ingredientes, la tradición en torno a la comida o la influencia religiosa en la manera de comer.
        </p>
        <center>
            <div class="container mt-5">
                <img src="imagenes/gastronomia" width="500px" heigth="500px">
            </div>
        </center>
        <br>
        <h4 class="subtitle">Agencia de Empleos en Honduras</h4>
        <p class="contenido">
            Las agencias para conseguir empleo en Honduras son una ayuda muy importante si estás interesado en encontrar
            un trabajo con excelentes remuneraciones. Debido a que Honduras es un país de escasos recursos, es necesario
            hallar una buena oportunidad laboral de manera inmediata.

            Las oficinas de trabajo en este país son una de las opciones de mayor prioridad entre muchas otras. Ya que,
            estas juegan un papel muy importante, porque suelen tener contacto con las empresas de más renombre de todo
            el territorio nacional.

            Sin embargo, a pesar de todo Honduras se encuentra en una importante recuperación económica y esto es una de
            las promesas más esperadas de cara al futuro.
        </p>
        <center>
            <div class="container mt-5">
                <img src="imagenes/trabajowebp" width="500px" heigth="500px">
            </div>
        </center>
        <br>
    </div>
    <div class="container mt-5">
        <hr>
        <h2 class="titleF">Informacion de codigos JavaScript o C++</h2>
        <br>

        <h4 class="subtitle">Algoritmo del Avestruz</h4>
        <p class="contenido">

            El método más simple es el algoritmo del avestruz: meta su cabeza en la arena y pretenda que no hay ningún
            problema. † Las personas reaccionan a esta estrategia de diversas formas. Los matemáticos la encuentran
            totalmente inaceptable y dicen que los interbloqueos se deben prevenir a toda costa; los ingenieros
            preguntan con qué frecuencia se espera el problema, con qué frecuencia falla el sistema por otras razones y
            qué tan grave es un interbloqueo. Si ocurren interbloqueos en promedio de una vez cada cinco años, pero los
            fallos del sistema debido al hardware, errores del compilador y errores en el sistema operativo ocurren una
            vez por semana, la mayoría de los ingenieros no estarán dispuestos a reducir considerablemente el
            rendimiento por la conveniencia de eliminar los interbloqueos. Para que este contraste sea más específico,
            considere un sistema operativo que bloquea al proceso llamador cuando no se puede llevar a cabo una llamada
            al sistema open en un dispositivo físico, como una unidad de CD-ROM o una impresora, debido a que el
            dispositivo está muy ocupado. Por lo general es responsabilidad del driver (controlador) de dispositivos
            decidir qué acción tomar bajo tales circunstancias. Bloquear o devolver una clave de error son dos
            posibilidades obvias. Si un proceso abre exitosamente la unidad de CD-ROM y otro la impresora, y después
            cada proceso trata de abrir el otro recurso y se bloquea en el intento, tenemos un interbloqueo. Pocos
            sistemas actuales detectarán esto.
        </p>
        <div class="container mt-5">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.57.40.jpeg" alt="" width="650px" heigth="780px">
        </div>
        <br>
        <h4 class="subtitle">Algoritmo del Banquero para un solo Recurso</h4>
        <p class="contenido">
            Dijkstra (1965) ideó un algoritmo de programación que puede evitar interbloqueos; este algoritmo se conoce
            como el algoritmo del banquero y es una extensión del algoritmo de detección de interbloqueos que se
            proporciona en la sección 3.4.1. Se modela de la forma en que un banquero de una pequeña ciudad podría
            tratar con un grupo de clientes a los que ha otorgado líneas de crédito. Lo que hace el algoritmo es
            comprobar si al otorgar la petición se produce un estado inseguro. Si es así, la petición se rechaza. Si al
            otorgar la petición se produce un estado seguro, se lleva a cabo. En la figura 6-11(a) podemos ver cuatro
            clientes, A, B, C y D, cada uno de los cuales ha recibido un cierto número de unidades de crédito (por
            ejemplo, 1 unidad es 1K dólares). El banquero sabe que no todos los clientes necesitan su crédito máximo de
            inmediato, por lo que ha reservado sólo 10 unidades en vez de 22 para darles servicio (en esta analogía, los
            clientes son procesos, las unidades son, por ejemplo, unidades de cinta, y el banquero es el sistema
            operativo).
            <br>
            Los clientes hacen sus respectivas labores, pidiendo préstamos de vez en cuando (es decir, solicitando
            recursos). En cierto momento, la situación es como se muestra en la figura 6-11(b). Este estado es seguro
            debido a que, con dos unidades restantes, el banquero puede retrasar cualquier petición excepto la de C, con
            lo cual deja que C termine y libere todos sus cuatro recursos. Con cuatro unidades a la mano, el banquero
            puede dejar que D o B tengan las unidades necesarias, y así en lo sucesivo. Considere lo que ocurriría si se
            otorgara una petición de B por una o más unidades en la figura 6-11(b). Tendríamos la situación de la figura
            6-11(c), que es insegura. Si todos los clientes pidieran de manera repentina sus préstamos máximos, el
            banquero no podría satisfacer a ninguno de ellos, y tendríamos un interbloqueo. Un estado inseguro no tiene
            que conducir a un interbloqueo, ya que un cliente tal vez no necesitaría toda la línea de crédito
            disponible, pero el banquero no podría contar con este comportamiento. El algoritmo del banquero considera
            cada petición a medida que va ocurriendo, y analiza si al otorgarla se produce un estado seguro. Si es así,
            se otorga la petición; en caso contrario, se pospone hasta más tarde. Para ver si un estado es seguro, el
            banquero comprueba si tiene los suficientes recursos para satisfacer a algún cliente. De ser así, se asume
            que esos préstamos volverán a pagarse y ahora se comprueba el cliente más cercano al límite, etcétera. Si
            todos los préstamos se pueden volver a pagar en un momento dado, el estado es seguro y la petición inicial
            se puede otorgar.
        </p>
        <div class="container mt-5">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 16.10.06 (1).jpeg" alt="" width="450px" heigth="580px">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 16.10.06.jpeg" alt="" width="450px" heigth="650px">
        <br>
        <br>
        <img src=""alt="" width="500px" heigth="600px">
        </div>
        <h4 class="subtitle">Algoritmo del Banquero para un solo Recursos.</h4>
        <p class="contenido">
            El algoritmo del banquero se puede generalizar para manejar varios recursos. La figura 6-12 muestra cómo
            funciona. En la figura 6-12 se muestran dos matrices. La de la izquierda muestra cuántas instancias de cada
            recurso están asignadas en un momento dado a cada uno de los cinco procesos. La matriz

            de la derecha muestra cuántos recursos sigue necesitando cada proceso para poder completarse. Estas matrices
            son sólo C y R de la figura 6-6. Al igual que en el caso con un solo recurso, los procesos deben declarar
            sus necesidades totales de recursos antes de ejecutarse, por lo que el sistema puede calcular la matriz
            derecha en cada instante. Los tres vectores a la derecha de la figura muestran los recursos existentes (E),
            los recursos poseídos (P) y los recursos disponibles (A), respectivamente. De E podemos ver que el sistema
            tiene seis unidades de cinta, tres trazadores, cuatro impresoras y dos unidades de CD-ROM. De éstos, ya hay
            asignados cinco unidades de cinta, tres trazadores, dos impresoras y dos unidades de CD-ROM. Este hecho
            puede verse al agregar las cuatro columnas de recursos en la matriz izquierda. El vector de recursos
            disponibles es simplemente la diferencia entre lo que tiene el sistema y lo que está en uso en un momento
            dado. Ahora se puede declarar el algoritmo para comprobar si un estado es seguro. 1. Buscar una fila R,
            cuyas necesidades de recursos no satisfechas sean menores o iguales que A. Si no existe dicha fila, el
            sistema entrará en interbloqueo en un momento dado, debido a que ningún proceso se podrá ejecutar hasta
            completarse (suponiendo que los procesos mantienen todos los recursos hasta que terminan). 2. Suponer que el
            proceso seleccionado de la fila solicita todos los recursos que necesita (lo que se garantiza que es
            posible) y termina. Marcar ese proceso como terminado y agregar todos sus recursos al vector A. 3. Repetir
            los pasos 1 y 2 hasta que todos los procesos se marquen como terminados (en cuyo caso el estado inicial era
            seguro) o hasta que no haya ningún proceso cuyas necesidades de recursos se puedan satisfacer (en cuyo caso
            hay un interbloqueo). Si hay varios procesos que pueden elegirse en el paso 1, no importa cuál esté
            seleccionado: la reserva de recursos disponibles aumentará, o en el peor caso, permanecerá igual.
            Ahora regresemos al ejemplo de la figura 6-12. El estado actual es seguro. Suponga que el proceso B ahora
            pide la impresora. Esa petición puede otorgarse debido a que el estado resultante es aún seguro (el proceso
            D puede terminar, y después los procesos A o E, seguidos por el resto). Ahora imagine que después de otorgar
            a B una de las dos impresoras restantes, E quiere la última impresora. Al otorgar esa petición se reduciría
            el vector de recursos disponibles a (1 0 0 0), lo cual produce un interbloqueo. Es evidente que la petición
            de E se debe diferir por unos momentos. El algoritmo del banquero fue publicado por primera vez por Dijkstra
            en 1965. Desde entonces, casi todos los libros sobre sistemas operativos lo han descrito con detalle. Se han
            escrito innumerables artículos sobre varios aspectos de él. Por desgracia, pocos autores han tenido la
            audacia de recalcar que, aunque en teoría el algoritmo es maravilloso, en la práctica es en esencia inútil,
            debido a que los procesos raras veces saben de antemano cuáles serán sus máximas necesidades de recursos.
            Además, el número de procesos no está fijo, sino que varía en forma dinámica a medida que los nuevos
            usuarios inician y cierran sesión. Por otro lado, los recursos que se consideraban disponibles pueden de
            pronto desvanecerse (las unidades de cinta se pueden descomponer). Por ende, en la práctica pocos (si acaso)
            sistemas existentes utilizan el algoritmo del banquero para evitar interbloqueos.
        </p>
        <div class="container mt-5">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 16.04.20 (1).jpeg" alt="" width="450px" heigth="580px">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 16.04.20.jpeg" alt="" width="450px" heigth="650px">
        <br>
        <br>
        <img src="imagenes/WhatsApp Image 2022-12-03 at 16.04.21 (1).jpeg"alt="" width="500px" heigth="600px">
        </div>
        <br>
        <h4 class="subtitle">Problema de los filósofos Comelones: </h4>
        <p class="contenido">
            También conocido como «El problema de los filósofos cenando» o «El problema de los filósofos comensales», es
            un problema clásico de las ciencias de la computación propuesto por el científico Edsger Dijkstra para
            representar los inconvenientes que plantea la sincronización de procesos en un sistema operativo.
            Independientemente de tenedores o palillos (yo optaré por estos últimos), el enunciado sería el siguiente:
            Hay cinco filósofos sentados alrededor de una mesa que pasan su vida cenando y pensando. Cada uno dispone de
            un plato de arroz y un palillo a la izquierda de su plato, pero para comer son necesarios dos palillos y
            cada filósofo sólo puede coger el que está a su izquierda o el que hay a su derecha. Con un solo palillo en
            la mano no tienen más remedio que esperar hasta que atrapen otro y puedan seguir comiendo.
            Si dos filósofos adyacentes intentan tomar el mismo palillo a la vez se produce una condición de carrera:
            ambos compiten por lo mismo, pero uno se queda sin comer.
            Si todos los filósofos cogen el palillo de su derecha al mismo tiempo, todos se quedarán esperando
            eternamente porque alguien debe liberar el palillo que les falta, cosa que nadie hará porque todos se
            encuentran en la misma situación (esperando que alguno deje su palillo). Llegado esto, los filósofos se
            morirán de hambre. A este bloqueo mutuo se le denomina interbloqueo o deadlock.
            El objetivo consiste en encontrar un recurso que permita que los filósofos nunca se mueran de hambre.
            Porque:Dos filósofos contiguos no pueden comer a la vez (exclusión mutua).
            Si un filósofo está comiendo, los contiguos no pueden hacerlo hasta que aquél termine (sincronización).
            El filósofo que termina de comer debe ceder los palillos para su posterior utilización (interbloqueo).
            Este sencillo planteamiento resulta muy útil para los que estudian informática porque ayuda a pensar en los
            sistemas que tienen recursos limitados (en el ejemplo anterior los palillos son limitados) y en los clientes
            (programas y usuarios): hay que darles servicio (comida) a todos en un tiempo razonable.
            Se trata de que los recursos sean utilizados de la manera más eficiente por todos los procesos implicados.
            Hay algoritmos para solucionarlo, pero todos los métodos pasan por asignar prioridades y/o tiempos máximos
            de uso de los recursos
        </p>
        <div class="container mt-5">
        <img src="imagenes/comelones1.jpeg" alt="" width="450px" heigth="600px">
        <img src="imagenes/come2.jpeg" alt="" width="650px" heigth="900px">
        <br>
        <br>
        <img src="imagenes/comelo3.jpeg" alt="" width="500px" heigth="600px">
        </div>
        <br>
        <h4 class="subtitle">Problema de Lectores Escritores</h4>
        <p class="contenido">
            Hay un objeto de datos (fichero de texto) que es utilizado por varios procesos, unos leen y otro que
            escribe. Solo puede utilizar el recurso un proceso y solo uno, es decir, o bien un proceso estará
            escribiendo o bien leyendo, pero nunca ocurrirá simultáneamente (teniendo en cuenta que, si no lo está
            utilizando nadie, tendrá preferencia el escritor ante el lector)
            Se considera a cada usuario (lector y escritor) como dos procesos y al fichero en cuestión como un recurso.
            De modo que, para que un proceso acceda al recurso que necesita, tenemos que considerar a cada usuario
            (lector y escritor) como dos semáforos. Estos semáforos son binarios y valen 0 si el recurso (fichero) está
            siendo utilizado por otro proceso y 1 si dicho recurso está disponible.
            La solución de este problema se basa en implementar un algoritmo eficiente en el manejo de semáforos y
            memoria compartida que seguidamente describimos. A lo largo del programa se utilizan funciones necesarias
            para el manejo de memoria compartida manejo de semáforos
            Para que el problema esté bien resuelto se tiene que cumplir:
            - No se puede hacer esperar a ningún proceso lector si ningún proceso escritor accede al recurso.
            - Cuando un escritor debe realizar su tarea, debe ocurrir cuanto antes, sin que deban interferir los
            procesos lectores (Para ello se establecen prioridades)
        </p>
        <div class="container mt-5">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.36.20.jpeg" alt="" width="450px" heigth="580px">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.36.33.jpeg" alt="" width="450px" heigth="650px">
        <br>
        <br>
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.36.43.jpeg" alt="" width="500px" heigth="600px">
        </div>
        <br>
        <h4 class="subtitle">Problema del Barbero Durmiente </h4>
        <p class="contenido">
            Uno de los problemas clásicos para el computo paralelo es el barbero durmiente. Según narra la historia,
            tenemos una barbería, con una única silla y un único barbero, el cual debe atender a todos los clientes que
            llegan. El problema consiste en un barbero durmiente que siempre se duerme cuando no existen clientes en
            espera, los cuales al llegar se sientan en una fila de sillas

            Si un cliente llega y el barbero esta durmiendo, este lo despierta y lo comienza a afeitar, pero si se
            encuentra atendiendo a otro cliente, se queda esperando en la silla hasta que el barbero se desocupe. En
            programación paralela, la zona critica es aquel recurso compartido que solo debe ser accedido por un solo
            hilo a la vez, para evitar la competencia por el recurso, y para ello el barbero durmiente ha sido uno de
            los problemas clásicos que utiliza mecanismo de exclusión mutua para resolver el problema de competencia por
            un recurso dentro de la región critica.

            Para ello se utilizan semáforos para proteger la variable compartida y así evitar que se sobre escriba,
            produciendo resultados no deseados en el resto de los hilos
        </p>
        <div class="container mt-5">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.40.34.jpeg" alt="" width="450px" heigth="580px">
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.40.44.jpeg" alt="" width="430px" heigth="630px">
        <br>
        <br>
        <img src="imagenes/WhatsApp Image 2022-12-03 at 15.40.53.jpeg" alt="" width="500px" heigth="600px">
        </div>
    </div>

    <div class="container mt-5">
        <hr>
        <center>
            <p class="font-footer">&copy; Derechos Reservados Grupo 3</p>
        </center>
    </div>
</body>

</html>